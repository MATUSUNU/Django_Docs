If you‚Äôre interested, run the command-line client for your database and type \dt (PostgreSQL),
SHOW TABLES; (MariaDB, MySQL), .tables (SQLite), or SELECT TABLE_NAME FROM USER_TABLES; (Oracle)
to display the tables Django created.

In our poll app, we‚Äôll create two models:
Question and Choice.
A Question has a question and a publication date.
A Choice has two fields: the text of the choice and a vote tally.
Each Choice is associated with a Question.

Django apps are ‚Äúpluggable‚Äù: You can use an app in multiple projects, and you can distribute apps,
because they don‚Äôt have to be tied to a given Django installation.

By running makemigrations, you‚Äôre telling Django that you‚Äôve made some changes to your models
There‚Äôs a command that will run the migrations for you and manage your database schema automatically - that‚Äôs called migrate

By convention DjangoTemplates looks for a ‚Äútemplates‚Äù subdirectory in each of the INSTALLED_APPS.

Namespacing URL names:
The tutorial project has just one app, polls. In real Django projects, there might be five, ten, twenty apps or more.
How does Django differentiate the URL names between them?
For example, the polls app has a detail view, and so might an app on the same project that is for a blog.
How does one make it so that Django knows which app view to create for a url when using the {% url %} template tag?

Since we‚Äôre creating a POST form (which can have the effect of modifying data), we need to worry about Cross Site Request Forgeries.
Thankfully, you don‚Äôt have to worry too hard, because Django comes with a helpful system for protecting against it.
In short, all POST forms that are targeted at internal URLs should use the {% csrf_token %} template tag.

As the Python comment above points out, you should always return an HttpResponseRedirect after successfully dealing with POST data.
This tip isn‚Äôt specific to Django; it‚Äôs good web development practice in general.

Note that the name of the matched pattern in the path strings of the second and third patterns has changed from <question_id> to <pk>.
This is necessary because we‚Äôll use the DetailView generic view to replace our detail() and results() views,
and it expects the primary key value captured from the URL to be called "pk".

By default, the DetailView generic view uses a template called <app name>/<model name>_detail.html.
In our case, it would use the template "polls/question_detail.html".
The template_name attribute is used to tell Django to use a specific template name instead of the autogenerated default template name.
We also specify the template_name for the results list view ‚Äì this ensures that the results view and the detail view have a different appearance when rendered,
even though they‚Äôre both a DetailView behind the scenes.
Similarly, the ListView generic view uses a default template called <app name>/<model name>_list.html;
we use template_name to tell ListView to use our existing "polls/index.html" template.

What are automated tests?
Tests are routines that check the operation of your code.
What‚Äôs different in automated tests is that the testing work is done for you by the system. You create a set of tests once,
and then as you make changes to your app, you can check that your code still works as you originally intended,
without having to perform time consuming manual testing.

Basic testing strategies
There are many ways to approach writing tests.

**Test-Driven Development (TDD)** is a software development approach where you:
1. **Write a test** for a small piece of functionality before writing the code.
2. **Write the minimal code** needed to pass that test.
3. **Refactor** the code while keeping the test green (passing).
üîÅ Repeat this cycle to build up your application.
In short:
> **‚ÄúRed ‚Üí Green ‚Üí Refactor‚Äù**

We identify a bug¬∂
Fortunately, there‚Äôs a little bug in the polls application for us to fix right away:
the Question.was_published_recently() method returns True if the Question was published within the last day (which is correct) but
also if the Question‚Äôs pub_date field is in the future (which certainly isn‚Äôt).

The Django test client
```
$ python manage.py shell
>>> from django.test.utils import setup_test_environment
>>> setup_test_environment()
```

Further testing
For example, while our tests here have covered some of the internal logic of a model and the way our views publish information,
you can use an ‚Äúin-browser‚Äù framework such as Selenium to test the way your HTML actually renders in a browser.
These tools allow you to check not just the behavior of your Django code, but also, for example, of your JavaScript.
It‚Äôs quite something to see the tests launch a browser, and start interacting with your site, as if a human being were driving it!
Django includes LiveServerTestCase to facilitate integration with tools like Selenium.
