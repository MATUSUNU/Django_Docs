If you’re interested, run the command-line client for your database and type \dt (PostgreSQL),
SHOW TABLES; (MariaDB, MySQL), .tables (SQLite), or SELECT TABLE_NAME FROM USER_TABLES; (Oracle)
to display the tables Django created.

In our poll app, we’ll create two models:
Question and Choice.
A Question has a question and a publication date.
A Choice has two fields: the text of the choice and a vote tally.
Each Choice is associated with a Question.

Django apps are “pluggable”: You can use an app in multiple projects, and you can distribute apps,
because they don’t have to be tied to a given Django installation.

By running makemigrations, you’re telling Django that you’ve made some changes to your models
There’s a command that will run the migrations for you and manage your database schema automatically - that’s called migrate

By convention DjangoTemplates looks for a “templates” subdirectory in each of the INSTALLED_APPS.

Namespacing URL names:
The tutorial project has just one app, polls. In real Django projects, there might be five, ten, twenty apps or more.
How does Django differentiate the URL names between them?
For example, the polls app has a detail view, and so might an app on the same project that is for a blog.
How does one make it so that Django knows which app view to create for a url when using the {% url %} template tag?

Since we’re creating a POST form (which can have the effect of modifying data), we need to worry about Cross Site Request Forgeries.
Thankfully, you don’t have to worry too hard, because Django comes with a helpful system for protecting against it.
In short, all POST forms that are targeted at internal URLs should use the {% csrf_token %} template tag.

As the Python comment above points out, you should always return an HttpResponseRedirect after successfully dealing with POST data.
This tip isn’t specific to Django; it’s good web development practice in general.

Note that the name of the matched pattern in the path strings of the second and third patterns has changed from <question_id> to <pk>.
This is necessary because we’ll use the DetailView generic view to replace our detail() and results() views,
and it expects the primary key value captured from the URL to be called "pk".

By default, the DetailView generic view uses a template called <app name>/<model name>_detail.html.
In our case, it would use the template "polls/question_detail.html".
The template_name attribute is used to tell Django to use a specific template name instead of the autogenerated default template name.
We also specify the template_name for the results list view – this ensures that the results view and the detail view have a different appearance when rendered,
even though they’re both a DetailView behind the scenes.
Similarly, the ListView generic view uses a default template called <app name>/<model name>_list.html;
we use template_name to tell ListView to use our existing "polls/index.html" template.
